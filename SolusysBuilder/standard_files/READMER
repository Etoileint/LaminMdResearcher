#!/bin/csh

# Generated by CHARMM-GUI (http://www.charmm-gui.org) v3.7
# Modified by ★Magichoco★

# 确保所有步骤按顺序执行，自动续跑未完成步骤

# Gmx mdp preparation ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
set production_stages = 100   # 生产阶段数
set production_total_time = 100 # 总时长(ns)

# 调用生成脚本
bash ProductionMdpGenerator $production_stages $production_total_time
echo "生产阶段用mdp文件生成完成"

# Gmx mdrun ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
set init = step3_input
set mini_prefix = step4.0_minimization
set equi_prefix = step4.1_equilibration
set prod_prefix = step5_production
set prod_step   = step5
set traj = ( zero.xtc )

# ==================== 功能函数定义 ====================
alias check_file 'if (-e \!*) echo "检测到文件 \!* 存在"; if (! -e \!*) echo "未找到文件 \!*"'

# Minimization ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
echo "\n====== 正在检查能量最小化步骤 ======"
check_file ${mini_prefix}.cplchk

if (! -e ${mini_prefix}.cplchk) then
    echo "启动能量最小化..."
    if (! -e ${mini_prefix}.tpr) then
        gmx grompp -f ${mini_prefix}.mdp -o ${mini_prefix}.tpr -c ${init}.gro -r ${init}.gro -p topol.top -n index.ndx -maxwarn 1 || exit 1
    endif
    
    if (-e ${mini_prefix}.cpt) then
        echo "检测到中断的cpt文件，尝试续跑..."
        gmx mdrun -v -deffnm ${mini_prefix} -cpi ${mini_prefix}.cpt || exit 1
    else
        gmx mdrun -v -deffnm ${mini_prefix} || exit 1
    endif
    date > ${mini_prefix}.cplchk
    echo "生成完成标识文件 ${mini_prefix}.cplchk"
else
    echo "能量最小化已完成，跳过"
endif

# Equilibration ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
echo "\n====== 正在检查预平衡步骤 ======"
check_file ${equi_prefix}.cplchk

if (! -e ${equi_prefix}.cplchk) then
    if (! -e ${mini_prefix}.cplchk) then
        echo "错误：能量最小化未完成，无法进行预平衡"
        exit 1
    endif

    echo "启动预平衡..."
    if (! -e ${equi_prefix}.tpr) then
        gmx grompp -f ${equi_prefix}.mdp -o ${equi_prefix}.tpr -c ${mini_prefix}.gro -r ${init}.gro -p topol.top -n index.ndx || exit 1
    endif
    
    if (-e ${equi_prefix}.cpt) then
        echo "检测到中断的cpt文件，尝试续跑..."
        gmx mdrun -v -deffnm ${equi_prefix} -cpi ${equi_prefix}.cpt || exit 1
    else
        gmx mdrun -v -deffnm ${equi_prefix} || exit 1
    endif
    date > ${equi_prefix}.cplchk
    echo "生成完成标识文件 ${equi_prefix}.cplchk"
else
    echo "预平衡已完成，跳过"
endif

# Production ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
echo "\n====== 正在处理生产阶段 ======"
set cnt = 1
while ($cnt <= $production_stages)
    set istep = ${prod_step}_${cnt}
    set crmdp = ${prod_step}.${cnt}_production
    check_file ${istep}.cplchk

    if (-e ${istep}.cplchk) then
        set traj = ( $traj ${istep}.xtc )
        echo "${istep} 已完成，跳过"
        @ cnt++
        continue
    endif

    if ($cnt == 1 && ! -e ${equi_prefix}.cplchk) then
        echo "错误：预平衡未完成，无法开始生产"
        exit 1
    endif

    if (! -e ${istep}.tpr) then
        echo "生成 ${istep}.tpr ..."
        if ($cnt == 1) then
            gmx grompp -f ${crmdp}.mdp -o ${istep}.tpr -c ${equi_prefix}.gro -p topol.top -n index.ndx || exit 1
        else
            @ prev_cnt = $cnt - 1
            set prev_istep = ${prod_step}_${prev_cnt}
            if (! -e ${prev_istep}.cplchk) then
                echo "错误：前置步骤 ${prev_istep} 未完成"
                exit 1
            endif
            gmx grompp -f ${crmdp}.mdp -o ${istep}.tpr -c ${prev_istep}.gro -t ${prev_istep}.cpt -p topol.top -n index.ndx || exit 1
        endif
    endif

    echo "启动步骤 ${istep} ..."
    if (-e ${istep}.cpt) then
        echo "检测到检查点文件，尝试续跑..."
        gmx mdrun -v -deffnm ${istep} -cpi ${istep}.cpt || exit 1
    else
        gmx mdrun -v -deffnm ${istep} || exit 1
    endif

    set traj = ( $traj ${istep}.xtc )
    date > ${istep}.cplchk
    echo "生成完成标识文件 ${istep}.cplchk"

    # 删除前一步的.gro（从第三步开始且阶段数>2）
    if ($cnt >= 3 && $production_stages > 2) then
        @ prev_cnt = $cnt - 1
        set prev_istep = ${prod_step}_${prev_cnt}
        if (-e ${prev_istep}.gro) then
            echo "删除前一步的.gro文件: ${prev_istep}.gro"
            rm -f ${prev_istep}.gro
        endif
    endif

    @ cnt++
end

# Trajectory Merge ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
set traj_list = ($traj)
shift traj_list  # 移除初始的"zero.xtc"

if ($#traj_list < 1) then
    echo "错误：未找到轨迹文件"
    exit 1
endif

# 处理第一个文件
set first_file = $traj_list[1]
set processed_files = "$first_file"

# 处理后续文件
if ($#traj_list > 1) then
    shift traj_list
    foreach file ($traj_list)
        set base = ${file:r}
        set processed = ${base}_skip1.xtc
        echo "正在处理 $file : 跳过第一帧..."
        
        gmx trjconv -f $file -o $processed -b 1 << END
0
END
        
        set processed_files = "$processed_files $processed"
    end
endif

# 合并处理后的轨迹
echo "\n正在合并轨迹"
gmx trjcat -f $processed_files -o combined_tf.xtc -cat

# 清理临时文件
foreach temp ($processed_files[2-])
    rm -f $temp
end

echo "轨迹合并完成，最终文件：combined_tf.xtc"

gmx trjconv -f combined_tf.xtc -o combined.xtc -timestep 10

# Trajectory Repair ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
echo "1" | gmx trjconv -s ${prod_step}_1.tpr -f combined.xtc -o combined_whole.xtc -pbc whole # 修复分子完整性
echo "1" | gmx trjconv -s ${prod_step}_1.tpr -f combined_whole.xtc -o combined_nojump.xtc -pbc nojump # 消除漂移
echo -e "1\n1" | gmx trjconv -s ${prod_step}_1.tpr -f combined_nojump.xtc -o combined_final.xtc -center -pbc mol # 中心重置
echo "1" | gmx trjconv -s ${prod_step}_1.tpr -f combined_final.xtc -o combined_finalfix.xtc -pbc nojump # 再次消除漂移
echo "轨迹修复完成，最终文件：combined_finalfix.xtc"

